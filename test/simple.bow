type A
type B
type C

let diag : A -> (A * A) =
  fun a -> <a, a>

let pr : (B * A) -> A =
  fun p -> snd p

let unit : A -> ♮A = 
  fun a -> [undin _a]

let counit : (♮A) -> A = 
  fun a -> [undout a]

let idem : (♮♮A) -> ♮A = 
  fun a -> [undin [undout [undout _a]]]

let sym : (A ⊗ B) -> (B ⊗ A) = 
  fun p -> 
  tensormatch p at B ⊗ A with
    xc#x ⊗ yc#y -> << yc # y , xc # x >> 

let assoc : ((A ⊗ B) ⊗ C) -> (A ⊗ (B ⊗ C)) = 
  fun t -> 
  tensormatch t at A ⊗ (B ⊗ C) with
  pc#p ⊗ zc#z -> 
    tensormatch (pc/pc' ⊗ zc/zc') | p, z at (pc' ⊗ zc') | pc'#p', zc'#z' -> A ⊗ (B ⊗ C) with
    p' = xc#x ⊗ yc#y -> << xc # x , yc zc' # << yc # y, zc' # z' >> >>

-- TODO: implement slice guessing
-- TODO: implement hom
-- TODO: implement counter examples, things that shouldn't typecheck
