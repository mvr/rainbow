type A
type B
type C

let diag : A -> (A * A) =
  fun a -> <a, a>

don't let tensordiag : A -> (A âŠ— A) =
  fun a -> << a, a >>

let pr : (B * A) -> A =
  fun p -> snd p

don't let tensorpr : (B âŠ— A) -> A =
  fun t ->  
  tensormatch t at A with       
    <<b, a>> -> a

let unit : A -> â™®A = 
  fun a -> undin _a

let counit : (â™®A) -> A = 
  fun a -> undout a

let idem : (â™®â™®A) -> â™®A = 
  fun a -> undin (undout (undout _a))

let sym : (A âŠ— B) -> (B âŠ— A) = 
  fun p -> 
  tensormatch p at B âŠ— A with
    <<x , y>> -> <<y, x>>

let assoc : ((A âŠ— B) âŠ— C) -> (A âŠ— (B âŠ— C)) = 
  fun t -> 
  tensormatch t at A âŠ— (B âŠ— C) with
  <<p, z>>[pc,zc] -> 
    tensormatch (pc/pc' âŠ— zc/zc') | p, z at (pc' âŠ— zc') | p'[pc'], z'[zc'] -> A âŠ— (B âŠ— C) with
    p' = <<x , y>> -> <<x, <<y, z'>> >>

let homunit : A -> (B âŠ¸ (A âŠ— B)) = 
  fun a -> hom b -o <<a, b>>

let homcounit : ((B âŠ¸ A) âŠ— B) -> A =
  fun t -> 
  tensormatch t at A with
    <<f , b>> -> (f @ b)

let homcurry : ((A âŠ— B) âŠ¸ C) -> (A âŠ¸ (B âŠ¸ C)) = 
  fun f ->
  hom a -o
  hom b -o
  (f @ << a, b >>)

-- let unitor : (A âŠ— ð•Š) -> A = 
--   fun t -> 
--   tensormatch t at A with
--   <<a, s>> -> 
--     unitmatch s at A with
--     <<>>^i -> a^i -- or âœ§?

-- TODO: allow not binding new colours
-- TODO: pretty printing
-- TODO: implement unit ?!?!
